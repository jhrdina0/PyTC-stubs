import ICSharpCode.SharpZipLib.Zip.Compression.Streams
import System
import System.Collections.Generic
import typing

class Deflater:
    @typing.overload
    def __init__(self, ) -> None: ...
    @typing.overload
    def __init__(self, level: int) -> None: ...
    @typing.overload
    def __init__(self, level: int, noZlibHeaderOrFooter: bool) -> None: ...
    BEST_COMPRESSION: int
    BEST_SPEED: int
    DEFAULT_COMPRESSION: int
    NO_COMPRESSION: int
    DEFLATED: int
    Adler: int
    TotalIn: int
    TotalOut: int
    IsFinished: bool
    IsNeedingInput: bool
    def Reset(self) -> None: ...
    def get_Adler(self) -> int: ...
    def get_TotalIn(self) -> int: ...
    def get_TotalOut(self) -> int: ...
    def Flush(self) -> None: ...
    def Finish(self) -> None: ...
    def get_IsFinished(self) -> bool: ...
    def get_IsNeedingInput(self) -> bool: ...
    @typing.overload
    def SetInput(self, input: list[System.Byte]) -> None: ...
    @typing.overload
    def SetInput(self, input: list[System.Byte], offset: int, count: int) -> None: ...
    def SetLevel(self, level: int) -> None: ...
    def GetLevel(self) -> int: ...
    def SetStrategy(self, strategy: DeflateStrategy) -> None: ...
    @typing.overload
    def Deflate(self, output: list[System.Byte]) -> int: ...
    @typing.overload
    def Deflate(self, output: list[System.Byte], offset: int, length: int) -> int: ...
    @typing.overload
    def SetDictionary(self, dictionary: list[System.Byte]) -> None: ...
    @typing.overload
    def SetDictionary(self, dictionary: list[System.Byte], index: int, count: int) -> None: ...

class DeflaterConstants:
    MAX_BLOCK_SIZE: int
    GOOD_LENGTH: list[int]
    MAX_LAZY: list[int]
    NICE_LENGTH: list[int]
    MAX_CHAIN: list[int]
    COMPR_FUNC: list[int]
    DEBUGGING: bool
    STORED_BLOCK: int
    STATIC_TREES: int
    DYN_TREES: int
    PRESET_DICT: int
    DEFAULT_MEM_LEVEL: int
    MAX_MATCH: int
    MIN_MATCH: int
    MAX_WBITS: int
    WSIZE: int
    WMASK: int
    HASH_BITS: int
    HASH_SIZE: int
    HASH_MASK: int
    HASH_SHIFT: int
    MIN_LOOKAHEAD: int
    MAX_DIST: int
    PENDING_BUF_SIZE: int
    DEFLATE_STORED: int
    DEFLATE_FAST: int
    DEFLATE_SLOW: int

class DeflateStrategy(System.Enum, int):
    Default: DeflateStrategy = ...
    Filtered: DeflateStrategy = ...
    HuffmanOnly: DeflateStrategy = ...

class DeflaterEngine:
    @typing.overload
    def __init__(self, pending: DeflaterPending) -> None: ...
    @typing.overload
    def __init__(self, pending: DeflaterPending, noAdlerCalculation: bool) -> None: ...
    Adler: int
    TotalIn: int
    Strategy: DeflateStrategy
    def Deflate(self, flush: bool, finish: bool) -> bool: ...
    def SetInput(self, buffer: list[System.Byte], offset: int, count: int) -> None: ...
    def NeedsInput(self) -> bool: ...
    def SetDictionary(self, buffer: list[System.Byte], offset: int, length: int) -> None: ...
    def Reset(self) -> None: ...
    def ResetAdler(self) -> None: ...
    def get_Adler(self) -> int: ...
    def get_TotalIn(self) -> int: ...
    def get_Strategy(self) -> DeflateStrategy: ...
    def set_Strategy(self, value: DeflateStrategy) -> None: ...
    def SetLevel(self, level: int) -> None: ...
    def FillWindow(self) -> None: ...

class DeflaterHuffman:
    def __init__(self, pending: DeflaterPending) -> None: ...
    pending: DeflaterPending
    def Reset(self) -> None: ...
    def SendAllTrees(self, blTreeCodes: int) -> None: ...
    def CompressBlock(self) -> None: ...
    def FlushStoredBlock(self, stored: list[System.Byte], storedOffset: int, storedLength: int, lastBlock: bool) -> None: ...
    def FlushBlock(self, stored: list[System.Byte], storedOffset: int, storedLength: int, lastBlock: bool) -> None: ...
    def IsFull(self) -> bool: ...
    def TallyLit(self, literal: int) -> bool: ...
    def TallyDist(self, distance: int, length: int) -> bool: ...
    @staticmethod
    def BitReverse(toReverse: int) -> int: ...

class DeflaterPending(PendingBuffer):
    def __init__(self, ) -> None: ...

class Inflater:
    @typing.overload
    def __init__(self, ) -> None: ...
    @typing.overload
    def __init__(self, noHeader: bool) -> None: ...
    IsNeedingInput: bool
    IsNeedingDictionary: bool
    IsFinished: bool
    Adler: int
    TotalOut: int
    TotalIn: int
    RemainingInput: int
    def Reset(self) -> None: ...
    @typing.overload
    def SetDictionary(self, buffer: list[System.Byte]) -> None: ...
    @typing.overload
    def SetDictionary(self, buffer: list[System.Byte], index: int, count: int) -> None: ...
    @typing.overload
    def SetInput(self, buffer: list[System.Byte]) -> None: ...
    @typing.overload
    def SetInput(self, buffer: list[System.Byte], index: int, count: int) -> None: ...
    @typing.overload
    def Inflate(self, buffer: list[System.Byte]) -> int: ...
    @typing.overload
    def Inflate(self, buffer: list[System.Byte], offset: int, count: int) -> int: ...
    def get_IsNeedingInput(self) -> bool: ...
    def get_IsNeedingDictionary(self) -> bool: ...
    def get_IsFinished(self) -> bool: ...
    def get_Adler(self) -> int: ...
    def get_TotalOut(self) -> int: ...
    def get_TotalIn(self) -> int: ...
    def get_RemainingInput(self) -> int: ...

class InflaterDynHeader:
    def __init__(self, input: ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator) -> None: ...
    LiteralLengthTree: InflaterHuffmanTree
    DistanceTree: InflaterHuffmanTree
    def AttemptRead(self) -> bool: ...
    def get_LiteralLengthTree(self) -> InflaterHuffmanTree: ...
    def get_DistanceTree(self) -> InflaterHuffmanTree: ...

class InflaterHuffmanTree:
    def __init__(self, codeLengths: list[System.Byte]) -> None: ...
    defLitLenTree: InflaterHuffmanTree
    defDistTree: InflaterHuffmanTree
    def GetSymbol(self, input: ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator) -> int: ...

class PendingBuffer:
    @typing.overload
    def __init__(self, ) -> None: ...
    @typing.overload
    def __init__(self, bufferSize: int) -> None: ...
    BitCount: int
    IsFlushed: bool
    def Reset(self) -> None: ...
    def WriteByte(self, value: int) -> None: ...
    def WriteShort(self, value: int) -> None: ...
    def WriteInt(self, value: int) -> None: ...
    def WriteBlock(self, block: list[System.Byte], offset: int, length: int) -> None: ...
    def get_BitCount(self) -> int: ...
    def AlignToByte(self) -> None: ...
    def WriteBits(self, b: int, count: int) -> None: ...
    def WriteShortMSB(self, s: int) -> None: ...
    def get_IsFlushed(self) -> bool: ...
    def Flush(self, output: list[System.Byte], offset: int, length: int) -> int: ...
    def ToByteArray(self) -> list[System.Byte]: ...

class CompressionLevel(System.Enum, int):
    BEST_COMPRESSION: CompressionLevel = ...
    BEST_SPEED: CompressionLevel = ...
    DEFAULT_COMPRESSION: CompressionLevel = ...
    NO_COMPRESSION: CompressionLevel = ...
    DEFLATED: CompressionLevel = ...

class Tree:
    def __init__(self, dh: DeflaterHuffman, elems: int, minCodes: int, maxLength: int) -> None: ...
    freqs: list[int]
    length: list[System.Byte]
    minNumCodes: int
    numCodes: int
    def Reset(self) -> None: ...
    def WriteSymbol(self, code: int) -> None: ...
    def CheckEmpty(self) -> None: ...
    def SetStaticCodes(self, staticCodes: list[int], staticLengths: list[System.Byte]) -> None: ...
    def BuildCodes(self) -> None: ...
    def BuildTree(self) -> None: ...
    def GetEncodedLength(self) -> int: ...
    def CalcBLFreq(self, blTree: Tree) -> None: ...
    def WriteTree(self, blTree: Tree) -> None: ...

class <CreateStateMachine>d__7:
    def __init__(self, <>1__state: int) -> None: ...
    <>4__this: InflaterDynHeader

