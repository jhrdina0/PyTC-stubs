import Newtonsoft.Json
import Newtonsoft.Json.Serialization
import System
import System.Collections
import System.Collections.Generic
import System.Dynamic
import System.Globalization
import System.IO
import System.Linq.Expressions
import System.Numerics
import System.Reflection
import System.Reflection.Emit
import System.Runtime.CompilerServices
import System.Threading
import System.Threading.Tasks
import System.Xml
import typing

class AsyncUtils:
    False: list[bool]
    True: list[bool]
    @staticmethod
    @typing.overload
    def CancelIfRequestedAsync(cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def CancelIfRequestedAsync(cancellationToken: System.Threading.CancellationToken) -> list[T]: ...
    @staticmethod
    @typing.overload
    def FromCanceled(cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def FromCanceled(cancellationToken: System.Threading.CancellationToken) -> list[T]: ...
    @staticmethod
    @typing.overload
    def WriteAsync(writer: System.IO.TextWriter, value: System.Char, cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def WriteAsync(writer: System.IO.TextWriter, value: str, cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def WriteAsync(writer: System.IO.TextWriter, value: list[System.Char], start: int, count: int, cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    @staticmethod
    def ReadAsync(reader: System.IO.TextReader, buffer: list[System.Char], index: int, count: int, cancellationToken: System.Threading.CancellationToken) -> list[int]: ...
    @staticmethod
    def IsCompletedSucessfully(task: System.Threading.Tasks.Task) -> bool: ...

class Base64Encoder:
    def __init__(self, writer: System.IO.TextWriter) -> None: ...
    def Encode(self, buffer: list[System.Byte], index: int, count: int) -> None: ...
    def Flush(self) -> None: ...
    def EncodeAsync(self, buffer: list[System.Byte], index: int, count: int, cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    def FlushAsync(self, cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...

TFirst = typing.TypeVar('TFirst'), TSecond = typing.TypeVar('TSecond')

class BidirectionalDictionary[TFirst, TSecond]:
    @typing.overload
    def __init__(self, ) -> None: ...
    @typing.overload
    def __init__(self, firstEqualityComparer: list[TFirst], secondEqualityComparer: list[TSecond]) -> None: ...
    @typing.overload
    def __init__(self, firstEqualityComparer: list[TFirst], secondEqualityComparer: list[TSecond], duplicateFirstErrorMessage: str, duplicateSecondErrorMessage: str) -> None: ...
    def Set(self, first: TFirst, second: TSecond) -> None: ...
    def TryGetByFirst(self, first: TFirst, second: TSecond&) -> bool: ...
    def TryGetBySecond(self, second: TSecond, first: TFirst&) -> bool: ...

class CollectionUtils:
    @staticmethod
    def IsNullOrEmpty(collection: list[T]) -> bool: ...
    @staticmethod
    def AddRange(initial: list[T], collection: list[T]) -> None: ...
    @staticmethod
    def IsDictionaryType(type: System.Type) -> bool: ...
    @staticmethod
    @typing.overload
    def ResolveEnumerableCollectionConstructor(collectionType: System.Type, collectionItemType: System.Type) -> System.Reflection.ConstructorInfo: ...
    @staticmethod
    @typing.overload
    def ResolveEnumerableCollectionConstructor(collectionType: System.Type, collectionItemType: System.Type, constructorArgumentType: System.Type) -> System.Reflection.ConstructorInfo: ...
    @staticmethod
    @typing.overload
    def AddDistinct(list: list[T], value: T) -> bool: ...
    @staticmethod
    @typing.overload
    def AddDistinct(list: list[T], value: T, comparer: list[T]) -> bool: ...
    @staticmethod
    def ContainsValue(source: list[TSource], value: TSource, comparer: list[TSource]) -> bool: ...
    @staticmethod
    def AddRangeDistinct(list: list[T], values: list[T], comparer: list[T]) -> bool: ...
    @staticmethod
    def IndexOf(collection: list[T], predicate: dict[T, bool]) -> int: ...
    @staticmethod
    def Contains(list: list[T], value: T, comparer: System.Collections.IEqualityComparer) -> bool: ...
    @staticmethod
    def IndexOfReference(list: list[T], item: T) -> int: ...
    @staticmethod
    def FastReverse(list: list[T]) -> None: ...
    @staticmethod
    def ToMultidimensionalArray(values: System.Collections.IList, type: System.Type, rank: int) -> System.Array: ...
    @staticmethod
    def ArrayEmpty() -> list[T]: ...

class IWrappedCollection:
    def __init__(self , *args: typing.Any) -> None: ...
    UnderlyingCollection: typing.Any
    def get_UnderlyingCollection(self) -> typing.Any: ...

T = typing.TypeVar('T')

class CollectionWrapper[T]:
    @typing.overload
    def __init__(self, list: System.Collections.IList) -> None: ...
    @typing.overload
    def __init__(self, list: list[T]) -> None: ...
    Count: int
    IsReadOnly: bool
    UnderlyingCollection: typing.Any
    def Add(self, item: T) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: T) -> bool: ...
    def CopyTo(self, array: list[T], arrayIndex: int) -> None: ...
    def get_Count(self) -> int: ...
    def get_IsReadOnly(self) -> bool: ...
    def Remove(self, item: T) -> bool: ...
    def GetEnumerator(self) -> list[T]: ...
    def get_UnderlyingCollection(self) -> typing.Any: ...

class PrimitiveTypeCode(System.Enum, int):
    Empty: PrimitiveTypeCode = ...
    Object: PrimitiveTypeCode = ...
    Char: PrimitiveTypeCode = ...
    CharNullable: PrimitiveTypeCode = ...
    Boolean: PrimitiveTypeCode = ...
    BooleanNullable: PrimitiveTypeCode = ...
    SByte: PrimitiveTypeCode = ...
    SByteNullable: PrimitiveTypeCode = ...
    Int16: PrimitiveTypeCode = ...
    Int16Nullable: PrimitiveTypeCode = ...
    UInt16: PrimitiveTypeCode = ...
    UInt16Nullable: PrimitiveTypeCode = ...
    Int32: PrimitiveTypeCode = ...
    Int32Nullable: PrimitiveTypeCode = ...
    Byte: PrimitiveTypeCode = ...
    ByteNullable: PrimitiveTypeCode = ...
    UInt32: PrimitiveTypeCode = ...
    UInt32Nullable: PrimitiveTypeCode = ...
    Int64: PrimitiveTypeCode = ...
    Int64Nullable: PrimitiveTypeCode = ...
    UInt64: PrimitiveTypeCode = ...
    UInt64Nullable: PrimitiveTypeCode = ...
    Single: PrimitiveTypeCode = ...
    SingleNullable: PrimitiveTypeCode = ...
    Double: PrimitiveTypeCode = ...
    DoubleNullable: PrimitiveTypeCode = ...
    DateTime: PrimitiveTypeCode = ...
    DateTimeNullable: PrimitiveTypeCode = ...
    DateTimeOffset: PrimitiveTypeCode = ...
    DateTimeOffsetNullable: PrimitiveTypeCode = ...
    Decimal: PrimitiveTypeCode = ...
    DecimalNullable: PrimitiveTypeCode = ...
    Guid: PrimitiveTypeCode = ...
    GuidNullable: PrimitiveTypeCode = ...
    TimeSpan: PrimitiveTypeCode = ...
    TimeSpanNullable: PrimitiveTypeCode = ...
    BigInteger: PrimitiveTypeCode = ...
    BigIntegerNullable: PrimitiveTypeCode = ...
    Uri: PrimitiveTypeCode = ...
    String: PrimitiveTypeCode = ...
    Bytes: PrimitiveTypeCode = ...
    DBNull: PrimitiveTypeCode = ...

class TypeInformation:
    def __init__(self, type: System.Type, typeCode: PrimitiveTypeCode) -> None: ...
    Type: System.Type
    TypeCode: PrimitiveTypeCode
    def get_Type(self) -> System.Type: ...
    def get_TypeCode(self) -> PrimitiveTypeCode: ...

class ParseResult(System.Enum, int):
    None: ParseResult = ...
    Success: ParseResult = ...
    Overflow: ParseResult = ...
    Invalid: ParseResult = ...

class ConvertUtils:
    @staticmethod
    @typing.overload
    def GetTypeCode(t: System.Type) -> PrimitiveTypeCode: ...
    @staticmethod
    @typing.overload
    def GetTypeCode(t: System.Type, isEnum: bool) -> PrimitiveTypeCode: ...
    @staticmethod
    def GetTypeInformation(convertable: System.IConvertible) -> TypeInformation: ...
    @staticmethod
    def IsConvertible(t: System.Type) -> bool: ...
    @staticmethod
    def ParseTimeSpan(input: str) -> System.TimeSpan: ...
    @staticmethod
    def FromBigInteger(i: System.Numerics.BigInteger, targetType: System.Type) -> typing.Any: ...
    @staticmethod
    def Convert(initialValue: typing.Any, culture: System.Globalization.CultureInfo, targetType: System.Type) -> typing.Any: ...
    @staticmethod
    def ConvertOrCast(initialValue: typing.Any, culture: System.Globalization.CultureInfo, targetType: System.Type) -> typing.Any: ...
    @staticmethod
    def VersionTryParse(input: str, result: System.Version&) -> bool: ...
    @staticmethod
    def IsInteger(value: typing.Any) -> bool: ...
    @staticmethod
    def Int32TryParse(chars: list[System.Char], start: int, length: int, value: System.Int32&) -> ParseResult: ...
    @staticmethod
    def Int64TryParse(chars: list[System.Char], start: int, length: int, value: System.Int64&) -> ParseResult: ...
    @staticmethod
    def DecimalTryParse(chars: list[System.Char], start: int, length: int, value: System.Decimal&) -> ParseResult: ...
    @staticmethod
    def TryConvertGuid(s: str, g: System.Guid&) -> bool: ...
    @staticmethod
    def TryHexTextToInt(text: list[System.Char], start: int, end: int, value: System.Int32&) -> bool: ...

class ParserTimeZone(System.Enum, int):
    Unspecified: ParserTimeZone = ...
    Utc: ParserTimeZone = ...
    LocalWestOfUtc: ParserTimeZone = ...
    LocalEastOfUtc: ParserTimeZone = ...

class DateTimeUtils:
    @staticmethod
    def GetUtcOffset(d: System.DateTime) -> System.TimeSpan: ...
    @staticmethod
    def ToSerializationMode(kind: System.DateTimeKind) -> System.Xml.XmlDateTimeSerializationMode: ...

class IWrappedDictionary:
    def __init__(self , *args: typing.Any) -> None: ...
    UnderlyingDictionary: typing.Any
    def get_UnderlyingDictionary(self) -> typing.Any: ...

TKey = typing.TypeVar('TKey'), TValue = typing.TypeVar('TValue')

class DictionaryWrapper[TKey, TValue]:
    @typing.overload
    def __init__(self, dictionary: System.Collections.IDictionary) -> None: ...
    @typing.overload
    def __init__(self, dictionary: dict[TKey, TValue]) -> None: ...
    @typing.overload
    def __init__(self, dictionary: dict[TKey, TValue]) -> None: ...
    Keys: list[TKey]
    Values: list[TValue]
    Item: TValue
    Count: int
    IsReadOnly: bool
    UnderlyingDictionary: typing.Any
    @typing.overload
    def Add(self, key: TKey, value: TValue) -> None: ...
    @typing.overload
    def Add(self, item: dict[TKey, TValue]) -> None: ...
    def ContainsKey(self, key: TKey) -> bool: ...
    def get_Keys(self) -> list[TKey]: ...
    @typing.overload
    def Remove(self, key: TKey) -> bool: ...
    @typing.overload
    def Remove(self, item: dict[TKey, TValue]) -> bool: ...
    @typing.overload
    def Remove(self, key: typing.Any) -> None: ...
    def TryGetValue(self, key: TKey, value: TValue&) -> bool: ...
    def get_Values(self) -> list[TValue]: ...
    def get_Item(self, key: TKey) -> TValue: ...
    def set_Item(self, key: TKey, value: TValue) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: dict[TKey, TValue]) -> bool: ...
    def CopyTo(self, array: list[dict[TKey, TValue]], arrayIndex: int) -> None: ...
    def get_Count(self) -> int: ...
    def get_IsReadOnly(self) -> bool: ...
    def GetEnumerator(self) -> list[dict[TKey, TValue]]: ...
    def get_UnderlyingDictionary(self) -> typing.Any: ...

T = typing.TypeVar('T')

class DynamicProxy[T]:
    def __init__(self, ) -> None: ...
    def GetDynamicMemberNames(self, instance: T) -> list[str]: ...
    def TryBinaryOperation(self, instance: T, binder: System.Dynamic.BinaryOperationBinder, arg: typing.Any, result: System.Object&) -> bool: ...
    def TryConvert(self, instance: T, binder: System.Dynamic.ConvertBinder, result: System.Object&) -> bool: ...
    def TryCreateInstance(self, instance: T, binder: System.Dynamic.CreateInstanceBinder, args: list[typing.Any], result: System.Object&) -> bool: ...
    def TryDeleteIndex(self, instance: T, binder: System.Dynamic.DeleteIndexBinder, indexes: list[typing.Any]) -> bool: ...
    def TryDeleteMember(self, instance: T, binder: System.Dynamic.DeleteMemberBinder) -> bool: ...
    def TryGetIndex(self, instance: T, binder: System.Dynamic.GetIndexBinder, indexes: list[typing.Any], result: System.Object&) -> bool: ...
    def TryGetMember(self, instance: T, binder: System.Dynamic.GetMemberBinder, result: System.Object&) -> bool: ...
    def TryInvoke(self, instance: T, binder: System.Dynamic.InvokeBinder, args: list[typing.Any], result: System.Object&) -> bool: ...
    def TryInvokeMember(self, instance: T, binder: System.Dynamic.InvokeMemberBinder, args: list[typing.Any], result: System.Object&) -> bool: ...
    def TrySetIndex(self, instance: T, binder: System.Dynamic.SetIndexBinder, indexes: list[typing.Any], value: typing.Any) -> bool: ...
    def TrySetMember(self, instance: T, binder: System.Dynamic.SetMemberBinder, value: typing.Any) -> bool: ...
    def TryUnaryOperation(self, instance: T, binder: System.Dynamic.UnaryOperationBinder, result: System.Object&) -> bool: ...

T = typing.TypeVar('T')

class DynamicProxyMetaObject[T](System.Dynamic.DynamicMetaObject):
    def BindGetMember(self, binder: System.Dynamic.GetMemberBinder) -> System.Dynamic.DynamicMetaObject: ...
    def BindSetMember(self, binder: System.Dynamic.SetMemberBinder, value: System.Dynamic.DynamicMetaObject) -> System.Dynamic.DynamicMetaObject: ...
    def BindDeleteMember(self, binder: System.Dynamic.DeleteMemberBinder) -> System.Dynamic.DynamicMetaObject: ...
    def BindConvert(self, binder: System.Dynamic.ConvertBinder) -> System.Dynamic.DynamicMetaObject: ...
    def BindInvokeMember(self, binder: System.Dynamic.InvokeMemberBinder, args: list[System.Dynamic.DynamicMetaObject]) -> System.Dynamic.DynamicMetaObject: ...
    def BindCreateInstance(self, binder: System.Dynamic.CreateInstanceBinder, args: list[System.Dynamic.DynamicMetaObject]) -> System.Dynamic.DynamicMetaObject: ...
    def BindInvoke(self, binder: System.Dynamic.InvokeBinder, args: list[System.Dynamic.DynamicMetaObject]) -> System.Dynamic.DynamicMetaObject: ...
    def BindBinaryOperation(self, binder: System.Dynamic.BinaryOperationBinder, arg: System.Dynamic.DynamicMetaObject) -> System.Dynamic.DynamicMetaObject: ...
    def BindUnaryOperation(self, binder: System.Dynamic.UnaryOperationBinder) -> System.Dynamic.DynamicMetaObject: ...
    def BindGetIndex(self, binder: System.Dynamic.GetIndexBinder, indexes: list[System.Dynamic.DynamicMetaObject]) -> System.Dynamic.DynamicMetaObject: ...
    def BindSetIndex(self, binder: System.Dynamic.SetIndexBinder, indexes: list[System.Dynamic.DynamicMetaObject], value: System.Dynamic.DynamicMetaObject) -> System.Dynamic.DynamicMetaObject: ...
    def BindDeleteIndex(self, binder: System.Dynamic.DeleteIndexBinder, indexes: list[System.Dynamic.DynamicMetaObject]) -> System.Dynamic.DynamicMetaObject: ...
    def GetDynamicMemberNames(self) -> list[str]: ...

class DynamicReflectionDelegateFactory(ReflectionDelegateFactory):
    def __init__(self, ) -> None: ...
    def CreateParameterizedConstructor(self, method: System.Reflection.MethodBase) -> list[typing.Any]: ...
    def CreateMethodCall(self, method: System.Reflection.MethodBase) -> dict[T, typing.Any]: ...
    def CreateDefaultConstructor(self, type: System.Type) -> list[T]: ...
    @typing.overload
    def CreateGet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateGet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...

class DynamicUtils:
    @staticmethod
    def GetDynamicMemberNames(dynamicProvider: System.Dynamic.IDynamicMetaObjectProvider) -> list[str]: ...

class NoThrowGetBinderMember(System.Dynamic.GetMemberBinder):
    def __init__(self, innerBinder: System.Dynamic.GetMemberBinder) -> None: ...
    def FallbackGetMember(self, target: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject) -> System.Dynamic.DynamicMetaObject: ...

class NoThrowSetBinderMember(System.Dynamic.SetMemberBinder):
    def __init__(self, innerBinder: System.Dynamic.SetMemberBinder) -> None: ...
    def FallbackSetMember(self, target: System.Dynamic.DynamicMetaObject, value: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject) -> System.Dynamic.DynamicMetaObject: ...

class NoThrowExpressionVisitor(System.Linq.Expressions.ExpressionVisitor):
    def __init__(self, ) -> None: ...

class EnumInfo:
    def __init__(self, isFlags: bool, values: list[System.UInt64], names: list[str], resolvedNames: list[str]) -> None: ...
    IsFlags: bool
    Values: list[System.UInt64]
    Names: list[str]
    ResolvedNames: list[str]

class EnumUtils:
    @staticmethod
    def GetFlagsValues(value: T) -> list[T]: ...
    @staticmethod
    @typing.overload
    def TryToString(enumType: System.Type, value: typing.Any, camelCase: bool, name: System.String&) -> bool: ...
    @staticmethod
    @typing.overload
    def TryToString(enumType: System.Type, value: typing.Any, namingStrategy: Newtonsoft.Json.Serialization.NamingStrategy, name: System.String&) -> bool: ...
    @staticmethod
    def GetEnumValuesAndNames(enumType: System.Type) -> EnumInfo: ...
    @staticmethod
    def ParseEnum(enumType: System.Type, namingStrategy: Newtonsoft.Json.Serialization.NamingStrategy, value: str, disallowNumber: bool) -> typing.Any: ...

class ExpressionReflectionDelegateFactory(ReflectionDelegateFactory):
    def __init__(self, ) -> None: ...
    def CreateParameterizedConstructor(self, method: System.Reflection.MethodBase) -> list[typing.Any]: ...
    def CreateMethodCall(self, method: System.Reflection.MethodBase) -> dict[T, typing.Any]: ...
    def CreateDefaultConstructor(self, type: System.Type) -> list[T]: ...
    @typing.overload
    def CreateGet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateGet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...

class FSharpFunction:
    def __init__(self, instance: typing.Any, invoker: dict[typing.Any, typing.Any]) -> None: ...
    def Invoke(self, args: list[typing.Any]) -> typing.Any: ...

class FSharpUtils:
    FSharpSetTypeName: str
    FSharpListTypeName: str
    FSharpMapTypeName: str
    Instance: FSharpUtils
    FSharpCoreAssembly: System.Reflection.Assembly
    IsUnion: dict[typing.Any, typing.Any]
    GetUnionCases: dict[typing.Any, typing.Any]
    PreComputeUnionTagReader: dict[typing.Any, typing.Any]
    PreComputeUnionReader: dict[typing.Any, typing.Any]
    PreComputeUnionConstructor: dict[typing.Any, typing.Any]
    GetUnionCaseInfoDeclaringType: dict[typing.Any, typing.Any]
    GetUnionCaseInfoName: dict[typing.Any, typing.Any]
    GetUnionCaseInfoTag: dict[typing.Any, typing.Any]
    GetUnionCaseInfoFields: dict[typing.Any, typing.Any]
    @staticmethod
    def get_Instance() -> FSharpUtils: ...
    def get_FSharpCoreAssembly(self) -> System.Reflection.Assembly: ...
    def get_IsUnion(self) -> dict[typing.Any, typing.Any]: ...
    def get_GetUnionCases(self) -> dict[typing.Any, typing.Any]: ...
    def get_PreComputeUnionTagReader(self) -> dict[typing.Any, typing.Any]: ...
    def get_PreComputeUnionReader(self) -> dict[typing.Any, typing.Any]: ...
    def get_PreComputeUnionConstructor(self) -> dict[typing.Any, typing.Any]: ...
    def get_GetUnionCaseInfoDeclaringType(self) -> dict[typing.Any, typing.Any]: ...
    def get_GetUnionCaseInfoName(self) -> dict[typing.Any, typing.Any]: ...
    def get_GetUnionCaseInfoTag(self) -> dict[typing.Any, typing.Any]: ...
    def get_GetUnionCaseInfoFields(self) -> dict[typing.Any, typing.Any]: ...
    @staticmethod
    def EnsureInitialized(fsharpCoreAssembly: System.Reflection.Assembly) -> None: ...
    def CreateSeq(self, t: System.Type) -> list[typing.Any]: ...
    def CreateMap(self, keyType: System.Type, valueType: System.Type) -> list[typing.Any]: ...
    def BuildMapCreator(self) -> list[typing.Any]: ...

class ILGeneratorExtensions:
    @staticmethod
    def PushInstance(generator: System.Reflection.Emit.ILGenerator, type: System.Type) -> None: ...
    @staticmethod
    def PushArrayInstance(generator: System.Reflection.Emit.ILGenerator, argsIndex: int, arrayIndex: int) -> None: ...
    @staticmethod
    def BoxIfNeeded(generator: System.Reflection.Emit.ILGenerator, type: System.Type) -> None: ...
    @staticmethod
    def UnboxIfNeeded(generator: System.Reflection.Emit.ILGenerator, type: System.Type) -> None: ...
    @staticmethod
    def CallMethod(generator: System.Reflection.Emit.ILGenerator, methodInfo: System.Reflection.MethodInfo) -> None: ...
    @staticmethod
    def Return(generator: System.Reflection.Emit.ILGenerator) -> None: ...

class ImmutableCollectionsUtils:
    pass

class BufferUtils:
    @staticmethod
    def RentBuffer(bufferPool: list[System.Char], minSize: int) -> list[System.Char]: ...
    @staticmethod
    def ReturnBuffer(bufferPool: list[System.Char], buffer: list[System.Char]) -> None: ...
    @staticmethod
    def EnsureBufferSize(bufferPool: list[System.Char], size: int, buffer: list[System.Char]) -> list[System.Char]: ...

class JavaScriptUtils:
    @staticmethod
    def GetCharEscapeFlags(stringEscapeHandling: Newtonsoft.Json.StringEscapeHandling, quoteChar: System.Char) -> list[bool]: ...
    @staticmethod
    def ShouldEscapeJavaScriptString(s: str, charEscapeFlags: list[bool]) -> bool: ...
    @staticmethod
    def WriteEscapedJavaScriptString(writer: System.IO.TextWriter, s: str, delimiter: System.Char, appendDelimiters: bool, charEscapeFlags: list[bool], stringEscapeHandling: Newtonsoft.Json.StringEscapeHandling, bufferPool: list[System.Char], writeBuffer: System.Char[]&) -> None: ...
    @staticmethod
    def ToEscapedJavaScriptString(value: str, delimiter: System.Char, appendDelimiters: bool, stringEscapeHandling: Newtonsoft.Json.StringEscapeHandling) -> str: ...
    @staticmethod
    def WriteEscapedJavaScriptStringAsync(writer: System.IO.TextWriter, s: str, delimiter: System.Char, appendDelimiters: bool, charEscapeFlags: list[bool], stringEscapeHandling: Newtonsoft.Json.StringEscapeHandling, client: Newtonsoft.Json.JsonTextWriter, writeBuffer: list[System.Char], cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    @staticmethod
    def WriteCharAsync(task: System.Threading.Tasks.Task, writer: System.IO.TextWriter, c: System.Char, cancellationToken: System.Threading.CancellationToken) -> System.Threading.Tasks.Task: ...
    @staticmethod
    def TryGetDateFromConstructorJson(reader: Newtonsoft.Json.JsonReader, dateTime: System.DateTime&, errorMessage: System.String&) -> bool: ...

class JsonTokenUtils:
    pass

class LateBoundReflectionDelegateFactory(ReflectionDelegateFactory):
    def __init__(self, ) -> None: ...
    def CreateParameterizedConstructor(self, method: System.Reflection.MethodBase) -> list[typing.Any]: ...
    def CreateMethodCall(self, method: System.Reflection.MethodBase) -> dict[T, typing.Any]: ...
    def CreateDefaultConstructor(self, type: System.Type) -> list[T]: ...
    @typing.overload
    def CreateGet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateGet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...

class MathUtils:
    @staticmethod
    def IntLength(i: System.UInt64) -> int: ...
    @staticmethod
    def IntToHex(n: int) -> System.Char: ...
    @staticmethod
    def Min(val1: list[int], val2: list[int]) -> list[int]: ...
    @staticmethod
    @typing.overload
    def Max(val1: list[int], val2: list[int]) -> list[int]: ...
    @staticmethod
    @typing.overload
    def Max(val1: list[float], val2: list[float]) -> list[float]: ...
    @staticmethod
    def ApproxEquals(d1: float, d2: float) -> bool: ...

T = typing.TypeVar('T'), TResult = typing.TypeVar('TResult')

class MethodCall[T, TResult](System.MulticastDelegate):
    def __init__(self, object: typing.Any, method: System.IntPtr) -> None: ...
    def Invoke(self, target: T, args: list[typing.Any]) -> TResult: ...
    def BeginInvoke(self, target: T, args: list[typing.Any], callback: System.AsyncCallback, object: typing.Any) -> System.IAsyncResult: ...
    def EndInvoke(self, result: System.IAsyncResult) -> TResult: ...

T = typing.TypeVar('T')

class Creator[T](System.MulticastDelegate):
    def __init__(self, object: typing.Any, method: System.IntPtr) -> None: ...
    def Invoke(self) -> T: ...
    def BeginInvoke(self, callback: System.AsyncCallback, object: typing.Any) -> System.IAsyncResult: ...
    def EndInvoke(self, result: System.IAsyncResult) -> T: ...

class MiscellaneousUtils:
    @staticmethod
    def Assert(condition: bool, message: str) -> None: ...
    @staticmethod
    def ValueEquals(objA: typing.Any, objB: typing.Any) -> bool: ...
    @staticmethod
    def CreateArgumentOutOfRangeException(paramName: str, actualValue: typing.Any, message: str) -> System.ArgumentOutOfRangeException: ...
    @staticmethod
    def ToString(value: typing.Any) -> str: ...
    @staticmethod
    def ByteArrayCompare(a1: list[System.Byte], a2: list[System.Byte]) -> int: ...
    @staticmethod
    def GetPrefix(qualifiedName: str) -> str: ...
    @staticmethod
    def GetLocalName(qualifiedName: str) -> str: ...
    @staticmethod
    def GetQualifiedNameParts(qualifiedName: str, prefix: System.String&, localName: System.String&) -> None: ...

class ReflectionDelegateFactory:
    @typing.overload
    def CreateGet(self, memberInfo: System.Reflection.MemberInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateGet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateGet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, memberInfo: System.Reflection.MemberInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, fieldInfo: System.Reflection.FieldInfo) -> dict[T, typing.Any]: ...
    @typing.overload
    def CreateSet(self, propertyInfo: System.Reflection.PropertyInfo) -> dict[T, typing.Any]: ...
    def CreateMethodCall(self, method: System.Reflection.MethodBase) -> dict[T, typing.Any]: ...
    def CreateParameterizedConstructor(self, method: System.Reflection.MethodBase) -> list[typing.Any]: ...
    def CreateDefaultConstructor(self, type: System.Type) -> list[T]: ...

class ReflectionMember:
    def __init__(self, ) -> None: ...
    MemberType: System.Type
    Getter: dict[typing.Any, typing.Any]
    Setter: dict[typing.Any, typing.Any]
    def get_MemberType(self) -> System.Type: ...
    def set_MemberType(self, value: System.Type) -> None: ...
    def get_Getter(self) -> dict[typing.Any, typing.Any]: ...
    def set_Getter(self, value: dict[typing.Any, typing.Any]) -> None: ...
    def get_Setter(self) -> dict[typing.Any, typing.Any]: ...
    def set_Setter(self, value: dict[typing.Any, typing.Any]) -> None: ...

class ReflectionObject:
    Creator: list[typing.Any]
    Members: dict[str, ReflectionMember]
    def get_Creator(self) -> list[typing.Any]: ...
    def get_Members(self) -> dict[str, ReflectionMember]: ...
    def GetValue(self, target: typing.Any, member: str) -> typing.Any: ...
    def SetValue(self, target: typing.Any, member: str, value: typing.Any) -> None: ...
    def GetType(self, member: str) -> System.Type: ...
    @staticmethod
    @typing.overload
    def Create(t: System.Type, memberNames: list[str]) -> ReflectionObject: ...
    @staticmethod
    @typing.overload
    def Create(t: System.Type, creator: System.Reflection.MethodBase, memberNames: list[str]) -> ReflectionObject: ...

class ReflectionUtils:
    EmptyTypes: list[System.Type]
    @staticmethod
    def IsVirtual(propertyInfo: System.Reflection.PropertyInfo) -> bool: ...
    @staticmethod
    def GetBaseDefinition(propertyInfo: System.Reflection.PropertyInfo) -> System.Reflection.MethodInfo: ...
    @staticmethod
    def IsPublic(property: System.Reflection.PropertyInfo) -> bool: ...
    @staticmethod
    def GetObjectType(v: typing.Any) -> System.Type: ...
    @staticmethod
    def GetTypeName(t: System.Type, assemblyFormat: Newtonsoft.Json.TypeNameAssemblyFormatHandling, binder: Newtonsoft.Json.Serialization.ISerializationBinder) -> str: ...
    @staticmethod
    def HasDefaultConstructor(t: System.Type, nonPublic: bool) -> bool: ...
    @staticmethod
    @typing.overload
    def GetDefaultConstructor(t: System.Type) -> System.Reflection.ConstructorInfo: ...
    @staticmethod
    @typing.overload
    def GetDefaultConstructor(t: System.Type, nonPublic: bool) -> System.Reflection.ConstructorInfo: ...
    @staticmethod
    def IsNullable(t: System.Type) -> bool: ...
    @staticmethod
    def IsNullableType(t: System.Type) -> bool: ...
    @staticmethod
    def EnsureNotNullableType(t: System.Type) -> System.Type: ...
    @staticmethod
    def EnsureNotByRefType(t: System.Type) -> System.Type: ...
    @staticmethod
    def IsGenericDefinition(type: System.Type, genericInterfaceDefinition: System.Type) -> bool: ...
    @staticmethod
    @typing.overload
    def ImplementsGenericDefinition(type: System.Type, genericInterfaceDefinition: System.Type) -> bool: ...
    @staticmethod
    @typing.overload
    def ImplementsGenericDefinition(type: System.Type, genericInterfaceDefinition: System.Type, implementingType: System.Type&) -> bool: ...
    @staticmethod
    @typing.overload
    def InheritsGenericDefinition(type: System.Type, genericClassDefinition: System.Type) -> bool: ...
    @staticmethod
    @typing.overload
    def InheritsGenericDefinition(type: System.Type, genericClassDefinition: System.Type, implementingType: System.Type&) -> bool: ...
    @staticmethod
    def GetCollectionItemType(type: System.Type) -> System.Type: ...
    @staticmethod
    def GetDictionaryKeyValueTypes(dictionaryType: System.Type, keyType: System.Type&, valueType: System.Type&) -> None: ...
    @staticmethod
    def GetMemberUnderlyingType(member: System.Reflection.MemberInfo) -> System.Type: ...
    @staticmethod
    def IsByRefLikeType(type: System.Type) -> bool: ...
    @staticmethod
    def IsIndexedProperty(property: System.Reflection.PropertyInfo) -> bool: ...
    @staticmethod
    def GetMemberValue(member: System.Reflection.MemberInfo, target: typing.Any) -> typing.Any: ...
    @staticmethod
    def SetMemberValue(member: System.Reflection.MemberInfo, target: typing.Any, value: typing.Any) -> None: ...
    @staticmethod
    def CanReadMemberValue(member: System.Reflection.MemberInfo, nonPublic: bool) -> bool: ...
    @staticmethod
    def CanSetMemberValue(member: System.Reflection.MemberInfo, nonPublic: bool, canSetReadOnly: bool) -> bool: ...
    @staticmethod
    def GetFieldsAndProperties(type: System.Type, bindingAttr: System.Reflection.BindingFlags) -> list[System.Reflection.MemberInfo]: ...
    @staticmethod
    @typing.overload
    def GetAttribute(attributeProvider: typing.Any) -> T: ...
    @staticmethod
    @typing.overload
    def GetAttribute(attributeProvider: typing.Any, inherit: bool) -> T: ...
    @staticmethod
    @typing.overload
    def GetAttributes(attributeProvider: typing.Any, inherit: bool) -> list[T]: ...
    @staticmethod
    @typing.overload
    def GetAttributes(attributeProvider: typing.Any, attributeType: System.Type, inherit: bool) -> list[System.Attribute]: ...
    @staticmethod
    def SplitFullyQualifiedTypeName(fullyQualifiedTypeName: str) -> dict[str, str]: ...
    @staticmethod
    def GetMemberInfoFromType(targetType: System.Type, memberInfo: System.Reflection.MemberInfo) -> System.Reflection.MemberInfo: ...
    @staticmethod
    def GetFields(targetType: System.Type, bindingAttr: System.Reflection.BindingFlags) -> list[System.Reflection.FieldInfo]: ...
    @staticmethod
    def GetProperties(targetType: System.Type, bindingAttr: System.Reflection.BindingFlags) -> list[System.Reflection.PropertyInfo]: ...
    @staticmethod
    def RemoveFlag(bindingAttr: System.Reflection.BindingFlags, flag: System.Reflection.BindingFlags) -> System.Reflection.BindingFlags: ...
    @staticmethod
    def IsMethodOverridden(currentType: System.Type, methodDeclaringType: System.Type, method: str) -> bool: ...
    @staticmethod
    def GetDefaultValue(type: System.Type) -> typing.Any: ...

class StringReferenceExtensions:
    @staticmethod
    def IndexOf(s: StringReference, c: System.Char, startIndex: int, length: int) -> int: ...
    @staticmethod
    def StartsWith(s: StringReference, text: str) -> bool: ...
    @staticmethod
    def EndsWith(s: StringReference, text: str) -> bool: ...

class StringUtils:
    CarriageReturnLineFeed: str
    Empty: str
    CarriageReturn: System.Char
    LineFeed: System.Char
    Tab: System.Char
    @staticmethod
    def IsNullOrEmpty(value: str) -> bool: ...
    @staticmethod
    @typing.overload
    def FormatWith(format: str, provider: System.IFormatProvider, arg0: typing.Any) -> str: ...
    @staticmethod
    @typing.overload
    def FormatWith(format: str, provider: System.IFormatProvider, arg0: typing.Any, arg1: typing.Any) -> str: ...
    @staticmethod
    @typing.overload
    def FormatWith(format: str, provider: System.IFormatProvider, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> str: ...
    @staticmethod
    @typing.overload
    def FormatWith(format: str, provider: System.IFormatProvider, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any, arg3: typing.Any) -> str: ...
    @staticmethod
    def IsWhiteSpace(s: str) -> bool: ...
    @staticmethod
    def CreateStringWriter(capacity: int) -> System.IO.StringWriter: ...
    @staticmethod
    def ToCharAsUnicode(c: System.Char, buffer: list[System.Char]) -> None: ...
    @staticmethod
    def ForgivingCaseSensitiveFind(source: list[TSource], valueSelector: dict[TSource, str], testValue: str) -> TSource: ...
    @staticmethod
    def ToCamelCase(s: str) -> str: ...
    @staticmethod
    def ToSnakeCase(s: str) -> str: ...
    @staticmethod
    def ToKebabCase(s: str) -> str: ...
    @staticmethod
    def IsHighSurrogate(c: System.Char) -> bool: ...
    @staticmethod
    def IsLowSurrogate(c: System.Char) -> bool: ...
    @staticmethod
    def StartsWith(source: str, value: System.Char) -> bool: ...
    @staticmethod
    def EndsWith(source: str, value: System.Char) -> bool: ...
    @staticmethod
    def Trim(s: str, start: int, length: int) -> str: ...

TKey = typing.TypeVar('TKey'), TValue = typing.TypeVar('TValue')

class ThreadSafeStore[TKey, TValue]:
    def __init__(self, creator: dict[TKey, TValue]) -> None: ...
    def Get(self, key: TKey) -> TValue: ...

class TypeExtensions:
    @staticmethod
    def Method(d: System.Delegate) -> System.Reflection.MethodInfo: ...
    @staticmethod
    def MemberType(memberInfo: System.Reflection.MemberInfo) -> System.Reflection.MemberTypes: ...
    @staticmethod
    def ContainsGenericParameters(type: System.Type) -> bool: ...
    @staticmethod
    def IsInterface(type: System.Type) -> bool: ...
    @staticmethod
    def IsGenericType(type: System.Type) -> bool: ...
    @staticmethod
    def IsGenericTypeDefinition(type: System.Type) -> bool: ...
    @staticmethod
    def BaseType(type: System.Type) -> System.Type: ...
    @staticmethod
    def Assembly(type: System.Type) -> System.Reflection.Assembly: ...
    @staticmethod
    def IsEnum(type: System.Type) -> bool: ...
    @staticmethod
    def IsClass(type: System.Type) -> bool: ...
    @staticmethod
    def IsSealed(type: System.Type) -> bool: ...
    @staticmethod
    def IsAbstract(type: System.Type) -> bool: ...
    @staticmethod
    def IsVisible(type: System.Type) -> bool: ...
    @staticmethod
    def IsValueType(type: System.Type) -> bool: ...
    @staticmethod
    def IsPrimitive(type: System.Type) -> bool: ...
    @staticmethod
    @typing.overload
    def AssignableToTypeName(type: System.Type, fullTypeName: str, searchInterfaces: bool, match: System.Type&) -> bool: ...
    @staticmethod
    @typing.overload
    def AssignableToTypeName(type: System.Type, fullTypeName: str, searchInterfaces: bool) -> bool: ...
    @staticmethod
    def ImplementInterface(type: System.Type, interfaceType: System.Type) -> bool: ...

class ValidationUtils:
    @staticmethod
    def ArgumentNotNull(value: typing.Any, parameterName: str) -> None: ...

class <>c:
    def __init__(self, ) -> None: ...
    <>9: <>c
    <>9__5_0: System.Action

T = typing.TypeVar('T')

class <>c__6[T]:
    def __init__(self, ) -> None: ...
    <>9: list[T]
    <>9__6_0: list[T]

T = typing.TypeVar('T')

class EmptyArrayContainer[T]:
    Empty: list[T]

class ConvertResult(System.Enum, int):
    Success: ConvertResult = ...
    CannotConvertNull: ConvertResult = ...
    NotInstantiableType: ConvertResult = ...
    NoValidConversion: ConvertResult = ...

class <>c__DisplayClass8_0:
    def __init__(self, ) -> None: ...
    call: dict[typing.Any, typing.Any]

TKey = typing.TypeVar('TKey'), TValue = typing.TypeVar('TValue')

class <>c[TKey, TValue]:
    def __init__(self, ) -> None: ...
    <>9: dict[TKey, TValue]
    <>9__29_0: dict[System.Collections.DictionaryEntry, dict[TKey, TValue]]

T = typing.TypeVar('T')

class Fallback[T](System.MulticastDelegate):
    def __init__(self, object: typing.Any, method: System.IntPtr) -> None: ...
    def Invoke(self, errorSuggestion: System.Dynamic.DynamicMetaObject) -> System.Dynamic.DynamicMetaObject: ...
    def BeginInvoke(self, errorSuggestion: System.Dynamic.DynamicMetaObject, callback: System.AsyncCallback, object: typing.Any) -> System.IAsyncResult: ...
    def EndInvoke(self, result: System.IAsyncResult) -> System.Dynamic.DynamicMetaObject: ...

T = typing.TypeVar('T')

class GetBinderAdapter[T](System.Dynamic.GetMemberBinder):
    def FallbackGetMember(self, target: System.Dynamic.DynamicMetaObject, errorSuggestion: System.Dynamic.DynamicMetaObject) -> System.Dynamic.DynamicMetaObject: ...

T = typing.TypeVar('T')

class <>c__DisplayClass3_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.GetMemberBinder
    <>4__this: list[T]

T = typing.TypeVar('T')

class <>c__DisplayClass4_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.SetMemberBinder
    <>4__this: list[T]
    value: System.Dynamic.DynamicMetaObject

T = typing.TypeVar('T')

class <>c__DisplayClass5_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.DeleteMemberBinder
    <>4__this: list[T]

T = typing.TypeVar('T')

class <>c__DisplayClass6_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.ConvertBinder
    <>4__this: list[T]

T = typing.TypeVar('T')

class <>c__DisplayClass7_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.InvokeMemberBinder
    <>4__this: list[T]
    args: list[System.Dynamic.DynamicMetaObject]

T = typing.TypeVar('T')

class <>c__DisplayClass8_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.CreateInstanceBinder
    <>4__this: list[T]
    args: list[System.Dynamic.DynamicMetaObject]

T = typing.TypeVar('T')

class <>c__DisplayClass9_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.InvokeBinder
    <>4__this: list[T]
    args: list[System.Dynamic.DynamicMetaObject]

T = typing.TypeVar('T')

class <>c__DisplayClass10_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.BinaryOperationBinder
    <>4__this: list[T]
    arg: System.Dynamic.DynamicMetaObject

T = typing.TypeVar('T')

class <>c__DisplayClass11_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.UnaryOperationBinder
    <>4__this: list[T]

T = typing.TypeVar('T')

class <>c__DisplayClass12_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.GetIndexBinder
    <>4__this: list[T]
    indexes: list[System.Dynamic.DynamicMetaObject]

T = typing.TypeVar('T')

class <>c__DisplayClass13_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.SetIndexBinder
    <>4__this: list[T]
    indexes: list[System.Dynamic.DynamicMetaObject]
    value: System.Dynamic.DynamicMetaObject

T = typing.TypeVar('T')

class <>c__DisplayClass14_0[T]:
    def __init__(self, ) -> None: ...
    binder: System.Dynamic.DeleteIndexBinder
    <>4__this: list[T]
    indexes: list[System.Dynamic.DynamicMetaObject]

T = typing.TypeVar('T')

class <>c[T]:
    def __init__(self, ) -> None: ...
    <>9: list[T]
    <>9__18_0: dict[System.Dynamic.DynamicMetaObject, System.Linq.Expressions.Expression]

T = typing.TypeVar('T')

class <>c__DisplayClass11_0[T]:
    def __init__(self, ) -> None: ...
    constantValue: typing.Any

class BinderWrapper:
    CSharpAssemblyName: str
    @staticmethod
    def GetMember(name: str, context: System.Type) -> System.Runtime.CompilerServices.CallSiteBinder: ...
    @staticmethod
    def SetMember(name: str, context: System.Type) -> System.Runtime.CompilerServices.CallSiteBinder: ...

class <>c:
    def __init__(self, ) -> None: ...
    <>9: <>c
    <>9__3_0: dict[System.Runtime.Serialization.EnumMemberAttribute, str]

T = typing.TypeVar('T')

class <>c__4[T]:
    def __init__(self, ) -> None: ...
    <>9: list[T]
    <>9__4_0: dict[System.UInt64, bool]

class ByRefParameter:
    def __init__(self, value: System.Linq.Expressions.Expression, variable: System.Linq.Expressions.ParameterExpression, isOut: bool) -> None: ...
    Value: System.Linq.Expressions.Expression
    Variable: System.Linq.Expressions.ParameterExpression
    IsOut: bool

T = typing.TypeVar('T')

class <>c__DisplayClass7_0[T]:
    def __init__(self, ) -> None: ...
    type: System.Type

class <>c__DisplayClass52_0:
    def __init__(self, ) -> None: ...
    call: dict[typing.Any, typing.Any]
    invoke: dict[typing.Any, typing.Any]

TKey = typing.TypeVar('TKey'), TValue = typing.TypeVar('TValue')

class <>c__DisplayClass55_0[TKey, TValue]:
    def __init__(self, ) -> None: ...
    ctorDelegate: list[typing.Any]

TKey = typing.TypeVar('TKey'), TValue = typing.TypeVar('TValue')

class <>c__55[TKey, TValue]:
    def __init__(self, ) -> None: ...
    <>9: dict[TKey, TValue]
    <>9__55_1: dict[dict[TKey, TValue], dict[TKey, TValue]]

class ImmutableCollectionTypeInfo:
    def __init__(self, contractTypeName: str, createdTypeName: str, builderTypeName: str) -> None: ...
    ContractTypeName: str
    CreatedTypeName: str
    BuilderTypeName: str
    def get_ContractTypeName(self) -> str: ...
    def set_ContractTypeName(self, value: str) -> None: ...
    def get_CreatedTypeName(self) -> str: ...
    def set_CreatedTypeName(self, value: str) -> None: ...
    def get_BuilderTypeName(self) -> str: ...
    def set_BuilderTypeName(self, value: str) -> None: ...

class <>c__DisplayClass24_0:
    def __init__(self, ) -> None: ...
    name: str

class <>c:
    def __init__(self, ) -> None: ...
    <>9: <>c
    <>9__24_1: dict[System.Reflection.MethodInfo, bool]
    <>9__25_1: dict[System.Reflection.MethodInfo, bool]

class <>c__DisplayClass25_0:
    def __init__(self, ) -> None: ...
    name: str

class <>c__DisplayClass3_0:
    def __init__(self, ) -> None: ...
    c: System.Reflection.ConstructorInfo
    method: System.Reflection.MethodBase

T = typing.TypeVar('T')

class <>c__DisplayClass4_0[T]:
    def __init__(self, ) -> None: ...
    c: System.Reflection.ConstructorInfo
    method: System.Reflection.MethodBase

T = typing.TypeVar('T')

class <>c__DisplayClass5_0[T]:
    def __init__(self, ) -> None: ...
    type: System.Type
    constructorInfo: System.Reflection.ConstructorInfo

T = typing.TypeVar('T')

class <>c__DisplayClass6_0[T]:
    def __init__(self, ) -> None: ...
    propertyInfo: System.Reflection.PropertyInfo

T = typing.TypeVar('T')

class <>c__DisplayClass7_0[T]:
    def __init__(self, ) -> None: ...
    fieldInfo: System.Reflection.FieldInfo

T = typing.TypeVar('T')

class <>c__DisplayClass8_0[T]:
    def __init__(self, ) -> None: ...
    fieldInfo: System.Reflection.FieldInfo

T = typing.TypeVar('T')

class <>c__DisplayClass9_0[T]:
    def __init__(self, ) -> None: ...
    propertyInfo: System.Reflection.PropertyInfo

class <>c__DisplayClass11_0:
    def __init__(self, ) -> None: ...
    ctor: list[typing.Any]

class <>c__DisplayClass11_1:
    def __init__(self, ) -> None: ...
    call: dict[typing.Any, typing.Any]

class <>c__DisplayClass11_2:
    def __init__(self, ) -> None: ...
    call: dict[typing.Any, typing.Any]

class <>c:
    def __init__(self, ) -> None: ...
    <>9: <>c
    <>9__11_0: dict[System.Reflection.ConstructorInfo, bool]
    <>9__31_0: dict[System.Reflection.MemberInfo, str]
    <>9__39_0: dict[System.Reflection.ParameterInfo, System.Type]
    <>9__41_0: dict[System.Reflection.FieldInfo, bool]

class <>c__DisplayClass31_0:
    def __init__(self, ) -> None: ...
    memberInfo: System.Reflection.MemberInfo

class <>c__DisplayClass44_0:
    def __init__(self, ) -> None: ...
    subTypeProperty: System.Reflection.PropertyInfo

class <>c__DisplayClass44_1:
    def __init__(self, ) -> None: ...
    subTypePropertyDeclaringType: System.Type
    CS$<>8__locals1: <>c__DisplayClass44_0

class <>c__DisplayClass45_0:
    def __init__(self, ) -> None: ...
    method: str
    methodDeclaringType: System.Type

class SeparatedCaseState(System.Enum, int):
    Start: SeparatedCaseState = ...
    Lower: SeparatedCaseState = ...
    Upper: SeparatedCaseState = ...
    NewWord: SeparatedCaseState = ...

TSource = typing.TypeVar('TSource')

class <>c__DisplayClass14_0[TSource]:
    def __init__(self, ) -> None: ...
    valueSelector: dict[TSource, str]
    testValue: str

