import Newtonsoft.Json
import Newtonsoft.Json.Linq
import Newtonsoft.Json.Utilities
import System
import System.Collections.Generic
import System.Collections.ObjectModel
import System.Collections.Specialized
import System.ComponentModel
import System.Dynamic
import System.Threading
import System.Threading.Tasks
import typing

class CommentHandling(System.Enum, int):
    Ignore: CommentHandling = ...
    Load: CommentHandling = ...

class DuplicatePropertyNameHandling(System.Enum, int):
    Replace: DuplicatePropertyNameHandling = ...
    Ignore: DuplicatePropertyNameHandling = ...
    Error: DuplicatePropertyNameHandling = ...

class Extensions:
    @staticmethod
    def Ancestors(source: list[T]) -> list[JToken]: ...
    @staticmethod
    def AncestorsAndSelf(source: list[T]) -> list[JToken]: ...
    @staticmethod
    def Descendants(source: list[T]) -> list[JToken]: ...
    @staticmethod
    def DescendantsAndSelf(source: list[T]) -> list[JToken]: ...
    @staticmethod
    def Properties(source: list[JObject]) -> list[JProperty]: ...
    @staticmethod
    @typing.overload
    def Values(source: list[JToken], key: typing.Any) -> list[JToken]: ...
    @staticmethod
    @typing.overload
    def Values(source: list[JToken]) -> list[JToken]: ...
    @staticmethod
    @typing.overload
    def Values(source: list[JToken], key: typing.Any) -> list[U]: ...
    @staticmethod
    @typing.overload
    def Values(source: list[JToken]) -> list[U]: ...
    @staticmethod
    @typing.overload
    def Value(value: list[JToken]) -> U: ...
    @staticmethod
    @typing.overload
    def Value(value: list[T]) -> U: ...
    @staticmethod
    @typing.overload
    def Children(source: list[T]) -> list[JToken]: ...
    @staticmethod
    @typing.overload
    def Children(source: list[T]) -> list[U]: ...
    @staticmethod
    @typing.overload
    def AsJEnumerable(source: list[JToken]) -> list[JToken]: ...
    @staticmethod
    @typing.overload
    def AsJEnumerable(source: list[T]) -> list[T]: ...

class IJEnumerable:
    def __init__(self , *args: typing.Any) -> None: ...
    Item: list[JToken]
    def get_Item(self, key: typing.Any) -> list[JToken]: ...

class JArray(JContainer):
    @typing.overload
    def __init__(self, ) -> None: ...
    @typing.overload
    def __init__(self, other: JArray) -> None: ...
    @typing.overload
    def __init__(self, content: list[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Any) -> None: ...
    Type: JTokenType
    Item: JToken
    Item: JToken
    IsReadOnly: bool
    def WriteToAsync(self, writer: Newtonsoft.Json.JsonWriter, cancellationToken: System.Threading.CancellationToken, converters: list[Newtonsoft.Json.JsonConverter]) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, cancellationToken: System.Threading.CancellationToken) -> list[JArray]: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings, cancellationToken: System.Threading.CancellationToken) -> list[JArray]: ...
    def get_Type(self) -> JTokenType: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader) -> JArray: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings) -> JArray: ...
    @staticmethod
    @typing.overload
    def Parse(json: str) -> JArray: ...
    @staticmethod
    @typing.overload
    def Parse(json: str, settings: JsonLoadSettings) -> JArray: ...
    @staticmethod
    @typing.overload
    def FromObject(o: typing.Any) -> JArray: ...
    @staticmethod
    @typing.overload
    def FromObject(o: typing.Any, jsonSerializer: Newtonsoft.Json.JsonSerializer) -> JArray: ...
    def WriteTo(self, writer: Newtonsoft.Json.JsonWriter, converters: list[Newtonsoft.Json.JsonConverter]) -> None: ...
    @typing.overload
    def get_Item(self, key: typing.Any) -> JToken: ...
    @typing.overload
    def get_Item(self, index: int) -> JToken: ...
    @typing.overload
    def set_Item(self, key: typing.Any, value: JToken) -> None: ...
    @typing.overload
    def set_Item(self, index: int, value: JToken) -> None: ...
    def IndexOf(self, item: JToken) -> int: ...
    def Insert(self, index: int, item: JToken) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    def GetEnumerator(self) -> list[JToken]: ...
    def Add(self, item: JToken) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: JToken) -> bool: ...
    def CopyTo(self, array: list[JToken], arrayIndex: int) -> None: ...
    def get_IsReadOnly(self) -> bool: ...
    def Remove(self, item: JToken) -> bool: ...

class JConstructor(JContainer):
    @typing.overload
    def __init__(self, ) -> None: ...
    @typing.overload
    def __init__(self, other: JConstructor) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: list[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    Name: str
    Type: JTokenType
    Item: JToken
    def WriteToAsync(self, writer: Newtonsoft.Json.JsonWriter, cancellationToken: System.Threading.CancellationToken, converters: list[Newtonsoft.Json.JsonConverter]) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, cancellationToken: System.Threading.CancellationToken) -> list[JConstructor]: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings, cancellationToken: System.Threading.CancellationToken) -> list[JConstructor]: ...
    def get_Name(self) -> str: ...
    def set_Name(self, value: str) -> None: ...
    def get_Type(self) -> JTokenType: ...
    def WriteTo(self, writer: Newtonsoft.Json.JsonWriter, converters: list[Newtonsoft.Json.JsonConverter]) -> None: ...
    def get_Item(self, key: typing.Any) -> JToken: ...
    def set_Item(self, key: typing.Any, value: JToken) -> None: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader) -> JConstructor: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings) -> JConstructor: ...

class JContainer(JToken):
    HasValues: bool
    First: JToken
    Last: JToken
    Count: int
    def add_ListChanged(self, value: System.ComponentModel.ListChangedEventHandler) -> None: ...
    def remove_ListChanged(self, value: System.ComponentModel.ListChangedEventHandler) -> None: ...
    def add_AddingNew(self, value: System.ComponentModel.AddingNewEventHandler) -> None: ...
    def remove_AddingNew(self, value: System.ComponentModel.AddingNewEventHandler) -> None: ...
    def add_CollectionChanged(self, value: System.Collections.Specialized.NotifyCollectionChangedEventHandler) -> None: ...
    def remove_CollectionChanged(self, value: System.Collections.Specialized.NotifyCollectionChangedEventHandler) -> None: ...
    def get_HasValues(self) -> bool: ...
    def get_First(self) -> JToken: ...
    def get_Last(self) -> JToken: ...
    def Children(self) -> list[JToken]: ...
    def Values(self) -> list[T]: ...
    def Descendants(self) -> list[JToken]: ...
    def DescendantsAndSelf(self) -> list[JToken]: ...
    def Add(self, content: typing.Any) -> None: ...
    def AddFirst(self, content: typing.Any) -> None: ...
    def CreateWriter(self) -> Newtonsoft.Json.JsonWriter: ...
    def ReplaceAll(self, content: typing.Any) -> None: ...
    def RemoveAll(self) -> None: ...
    @typing.overload
    def Merge(self, content: typing.Any) -> None: ...
    @typing.overload
    def Merge(self, content: typing.Any, settings: JsonMergeSettings) -> None: ...
    def get_Count(self) -> int: ...

class JObject(JContainer):
    @typing.overload
    def __init__(self, ) -> None: ...
    @typing.overload
    def __init__(self, other: JObject) -> None: ...
    @typing.overload
    def __init__(self, content: list[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Any) -> None: ...
    Type: JTokenType
    Item: JToken
    Item: JToken
    def WriteToAsync(self, writer: Newtonsoft.Json.JsonWriter, cancellationToken: System.Threading.CancellationToken, converters: list[Newtonsoft.Json.JsonConverter]) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, cancellationToken: System.Threading.CancellationToken) -> list[JObject]: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings, cancellationToken: System.Threading.CancellationToken) -> list[JObject]: ...
    def add_PropertyChanged(self, value: System.ComponentModel.PropertyChangedEventHandler) -> None: ...
    def remove_PropertyChanged(self, value: System.ComponentModel.PropertyChangedEventHandler) -> None: ...
    def add_PropertyChanging(self, value: System.ComponentModel.PropertyChangingEventHandler) -> None: ...
    def remove_PropertyChanging(self, value: System.ComponentModel.PropertyChangingEventHandler) -> None: ...
    def get_Type(self) -> JTokenType: ...
    def Properties(self) -> list[JProperty]: ...
    @typing.overload
    def Property(self, name: str) -> JProperty: ...
    @typing.overload
    def Property(self, name: str, comparison: System.StringComparison) -> JProperty: ...
    def PropertyValues(self) -> list[JToken]: ...
    @typing.overload
    def get_Item(self, key: typing.Any) -> JToken: ...
    @typing.overload
    def get_Item(self, propertyName: str) -> JToken: ...
    @typing.overload
    def set_Item(self, key: typing.Any, value: JToken) -> None: ...
    @typing.overload
    def set_Item(self, propertyName: str, value: JToken) -> None: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader) -> JObject: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings) -> JObject: ...
    @staticmethod
    @typing.overload
    def Parse(json: str) -> JObject: ...
    @staticmethod
    @typing.overload
    def Parse(json: str, settings: JsonLoadSettings) -> JObject: ...
    @staticmethod
    @typing.overload
    def FromObject(o: typing.Any) -> JObject: ...
    @staticmethod
    @typing.overload
    def FromObject(o: typing.Any, jsonSerializer: Newtonsoft.Json.JsonSerializer) -> JObject: ...
    def WriteTo(self, writer: Newtonsoft.Json.JsonWriter, converters: list[Newtonsoft.Json.JsonConverter]) -> None: ...
    @typing.overload
    def GetValue(self, propertyName: str) -> JToken: ...
    @typing.overload
    def GetValue(self, propertyName: str, comparison: System.StringComparison) -> JToken: ...
    @typing.overload
    def TryGetValue(self, propertyName: str, comparison: System.StringComparison, value: JToken&) -> bool: ...
    @typing.overload
    def TryGetValue(self, propertyName: str, value: JToken&) -> bool: ...
    def Add(self, propertyName: str, value: JToken) -> None: ...
    def ContainsKey(self, propertyName: str) -> bool: ...
    def Remove(self, propertyName: str) -> bool: ...
    def GetEnumerator(self) -> list[dict[str, JToken]]: ...

class JProperty(JContainer):
    @typing.overload
    def __init__(self, other: JProperty) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: list[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Any) -> None: ...
    Name: str
    Value: JToken
    Type: JTokenType
    def WriteToAsync(self, writer: Newtonsoft.Json.JsonWriter, cancellationToken: System.Threading.CancellationToken, converters: list[Newtonsoft.Json.JsonConverter]) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, cancellationToken: System.Threading.CancellationToken) -> list[JProperty]: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings, cancellationToken: System.Threading.CancellationToken) -> list[JProperty]: ...
    def get_Name(self) -> str: ...
    def get_Value(self) -> JToken: ...
    def set_Value(self, value: JToken) -> None: ...
    def get_Type(self) -> JTokenType: ...
    def WriteTo(self, writer: Newtonsoft.Json.JsonWriter, converters: list[Newtonsoft.Json.JsonConverter]) -> None: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader) -> JProperty: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings) -> JProperty: ...

class JPropertyDescriptor(System.ComponentModel.PropertyDescriptor):
    def __init__(self, name: str) -> None: ...
    ComponentType: System.Type
    IsReadOnly: bool
    PropertyType: System.Type
    def CanResetValue(self, component: typing.Any) -> bool: ...
    def GetValue(self, component: typing.Any) -> typing.Any: ...
    def ResetValue(self, component: typing.Any) -> None: ...
    def SetValue(self, component: typing.Any, value: typing.Any) -> None: ...
    def ShouldSerializeValue(self, component: typing.Any) -> bool: ...
    def get_ComponentType(self) -> System.Type: ...
    def get_IsReadOnly(self) -> bool: ...
    def get_PropertyType(self) -> System.Type: ...

class JPropertyKeyedCollection(list[JToken]):
    def __init__(self, ) -> None: ...
    Item: JToken
    Keys: list[str]
    Values: list[JToken]
    def Contains(self, key: str) -> bool: ...
    def Remove(self, key: str) -> bool: ...
    def get_Item(self, key: str) -> JToken: ...
    def TryGetValue(self, key: str, value: JToken&) -> bool: ...
    def get_Keys(self) -> list[str]: ...
    def get_Values(self) -> list[JToken]: ...
    def IndexOfReference(self, t: JToken) -> int: ...
    def Compare(self, other: JPropertyKeyedCollection) -> bool: ...

class JRaw(JValue):
    @typing.overload
    def __init__(self, other: JRaw) -> None: ...
    @typing.overload
    def __init__(self, rawJson: typing.Any) -> None: ...
    @staticmethod
    def CreateAsync(reader: Newtonsoft.Json.JsonReader, cancellationToken: System.Threading.CancellationToken) -> list[JRaw]: ...
    @staticmethod
    def Create(reader: Newtonsoft.Json.JsonReader) -> JRaw: ...

class JsonLoadSettings:
    def __init__(self, ) -> None: ...
    CommentHandling: CommentHandling
    LineInfoHandling: LineInfoHandling
    DuplicatePropertyNameHandling: DuplicatePropertyNameHandling
    def get_CommentHandling(self) -> CommentHandling: ...
    def set_CommentHandling(self, value: CommentHandling) -> None: ...
    def get_LineInfoHandling(self) -> LineInfoHandling: ...
    def set_LineInfoHandling(self, value: LineInfoHandling) -> None: ...
    def get_DuplicatePropertyNameHandling(self) -> DuplicatePropertyNameHandling: ...
    def set_DuplicatePropertyNameHandling(self, value: DuplicatePropertyNameHandling) -> None: ...

class JsonMergeSettings:
    def __init__(self, ) -> None: ...
    MergeArrayHandling: MergeArrayHandling
    MergeNullValueHandling: MergeNullValueHandling
    PropertyNameComparison: System.StringComparison
    def get_MergeArrayHandling(self) -> MergeArrayHandling: ...
    def set_MergeArrayHandling(self, value: MergeArrayHandling) -> None: ...
    def get_MergeNullValueHandling(self) -> MergeNullValueHandling: ...
    def set_MergeNullValueHandling(self, value: MergeNullValueHandling) -> None: ...
    def get_PropertyNameComparison(self) -> System.StringComparison: ...
    def set_PropertyNameComparison(self, value: System.StringComparison) -> None: ...

class JsonSelectSettings:
    def __init__(self, ) -> None: ...
    RegexMatchTimeout: list[System.TimeSpan]
    ErrorWhenNoMatch: bool
    def get_RegexMatchTimeout(self) -> list[System.TimeSpan]: ...
    def set_RegexMatchTimeout(self, value: list[System.TimeSpan]) -> None: ...
    def get_ErrorWhenNoMatch(self) -> bool: ...
    def set_ErrorWhenNoMatch(self, value: bool) -> None: ...

class JToken:
    EqualityComparer: JTokenEqualityComparer
    Parent: JContainer
    Root: JToken
    Type: JTokenType
    HasValues: bool
    Next: JToken
    Previous: JToken
    Path: str
    Item: JToken
    First: JToken
    Last: JToken
    @typing.overload
    def ToObject(self, jsonSerializer: Newtonsoft.Json.JsonSerializer) -> T: ...
    @typing.overload
    def ToObject(self, objectType: System.Type, jsonSerializer: Newtonsoft.Json.JsonSerializer) -> typing.Any: ...
    @typing.overload
    def ToObject(self) -> T: ...
    @typing.overload
    def ToObject(self, objectType: System.Type) -> typing.Any: ...
    @staticmethod
    @typing.overload
    def ReadFrom(reader: Newtonsoft.Json.JsonReader) -> JToken: ...
    @staticmethod
    @typing.overload
    def ReadFrom(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings) -> JToken: ...
    @staticmethod
    @typing.overload
    def Parse(json: str) -> JToken: ...
    @staticmethod
    @typing.overload
    def Parse(json: str, settings: JsonLoadSettings) -> JToken: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings) -> JToken: ...
    @staticmethod
    @typing.overload
    def Load(reader: Newtonsoft.Json.JsonReader) -> JToken: ...
    @staticmethod
    @typing.overload
    def SelectToken(path: str) -> JToken: ...
    @staticmethod
    @typing.overload
    def SelectToken(path: str, errorWhenNoMatch: bool) -> JToken: ...
    @staticmethod
    @typing.overload
    def SelectToken(path: str, settings: JsonSelectSettings) -> JToken: ...
    @typing.overload
    def SelectTokens(self, path: str) -> list[JToken]: ...
    @typing.overload
    def SelectTokens(self, path: str, errorWhenNoMatch: bool) -> list[JToken]: ...
    @typing.overload
    def SelectTokens(self, path: str, settings: JsonSelectSettings) -> list[JToken]: ...
    @staticmethod
    def DeepClone() -> JToken: ...
    def AddAnnotation(self, annotation: typing.Any) -> None: ...
    @typing.overload
    def Annotation(self) -> T: ...
    @typing.overload
    def Annotation(self, type: System.Type) -> typing.Any: ...
    @typing.overload
    def Annotations(self) -> list[T]: ...
    @typing.overload
    def Annotations(self, type: System.Type) -> list[typing.Any]: ...
    @typing.overload
    def RemoveAnnotations(self) -> None: ...
    @typing.overload
    def RemoveAnnotations(self, type: System.Type) -> None: ...
    @typing.overload
    def WriteToAsync(self, writer: Newtonsoft.Json.JsonWriter, cancellationToken: System.Threading.CancellationToken, converters: list[Newtonsoft.Json.JsonConverter]) -> System.Threading.Tasks.Task: ...
    @typing.overload
    def WriteToAsync(self, writer: Newtonsoft.Json.JsonWriter, converters: list[Newtonsoft.Json.JsonConverter]) -> System.Threading.Tasks.Task: ...
    @staticmethod
    @typing.overload
    def ReadFromAsync(reader: Newtonsoft.Json.JsonReader, cancellationToken: System.Threading.CancellationToken) -> list[JToken]: ...
    @staticmethod
    @typing.overload
    def ReadFromAsync(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings, cancellationToken: System.Threading.CancellationToken) -> list[JToken]: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, cancellationToken: System.Threading.CancellationToken) -> list[JToken]: ...
    @staticmethod
    @typing.overload
    def LoadAsync(reader: Newtonsoft.Json.JsonReader, settings: JsonLoadSettings, cancellationToken: System.Threading.CancellationToken) -> list[JToken]: ...
    @staticmethod
    def get_EqualityComparer() -> JTokenEqualityComparer: ...
    def get_Parent(self) -> JContainer: ...
    @staticmethod
    def get_Root() -> JToken: ...
    def get_Type(self) -> JTokenType: ...
    def get_HasValues(self) -> bool: ...
    @staticmethod
    def DeepEquals(t1: JToken, t2: JToken) -> bool: ...
    @staticmethod
    def get_Next() -> JToken: ...
    @staticmethod
    def get_Previous() -> JToken: ...
    def get_Path(self) -> str: ...
    def AddAfterSelf(self, content: typing.Any) -> None: ...
    def AddBeforeSelf(self, content: typing.Any) -> None: ...
    def Ancestors(self) -> list[JToken]: ...
    def AncestorsAndSelf(self) -> list[JToken]: ...
    def AfterSelf(self) -> list[JToken]: ...
    def BeforeSelf(self) -> list[JToken]: ...
    @staticmethod
    def get_Item(key: typing.Any) -> JToken: ...
    def set_Item(self, key: typing.Any, value: JToken) -> None: ...
    def Value(self, key: typing.Any) -> T: ...
    @staticmethod
    def get_First() -> JToken: ...
    @staticmethod
    def get_Last() -> JToken: ...
    @typing.overload
    def Children(self) -> list[JToken]: ...
    @typing.overload
    def Children(self) -> list[T]: ...
    def Values(self) -> list[T]: ...
    def Remove(self) -> None: ...
    def Replace(self, value: JToken) -> None: ...
    def WriteTo(self, writer: Newtonsoft.Json.JsonWriter, converters: list[Newtonsoft.Json.JsonConverter]) -> None: ...
    @typing.overload
    def ToString(self) -> str: ...
    @typing.overload
    def ToString(self, formatting: Newtonsoft.Json.Formatting, converters: list[Newtonsoft.Json.JsonConverter]) -> str: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> bool: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.DateTimeOffset: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[bool]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> int: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.DateTime]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.DateTimeOffset]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.Decimal]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[float]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.Char]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> int: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> int: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.UInt16: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.Char: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.Byte: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.SByte: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[int]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[int]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.UInt16]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.Byte]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.SByte]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.DateTime: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[int]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[float]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.Decimal: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.UInt32]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.UInt64]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> float: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> float: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> str: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.UInt32: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.UInt64: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.Byte]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.Guid: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.Guid]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.TimeSpan: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> list[System.TimeSpan]: ...
    @staticmethod
    @typing.overload
    def op_Explicit(value: JToken) -> System.Uri: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: bool) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.DateTimeOffset) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.Byte) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.Byte]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.SByte) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.SByte]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[bool]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: int) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.DateTime]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.DateTimeOffset]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.Decimal]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[float]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: int) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.UInt16) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: int) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[int]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.DateTime) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[int]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[float]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.Decimal) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[int]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.UInt16]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.UInt32]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.UInt64]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: float) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: float) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: str) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.UInt32) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.UInt64) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.Byte]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.Uri) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.TimeSpan) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.TimeSpan]) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: System.Guid) -> JToken: ...
    @staticmethod
    @typing.overload
    def op_Implicit(value: list[System.Guid]) -> JToken: ...
    def CreateReader(self) -> Newtonsoft.Json.JsonReader: ...
    @staticmethod
    @typing.overload
    def FromObject(o: typing.Any) -> JToken: ...
    @staticmethod
    @typing.overload
    def FromObject(o: typing.Any, jsonSerializer: Newtonsoft.Json.JsonSerializer) -> JToken: ...

class JTokenEqualityComparer:
    def __init__(self, ) -> None: ...
    def Equals(self, x: JToken, y: JToken) -> bool: ...
    def GetHashCode(self, obj: JToken) -> int: ...

class JTokenReader(Newtonsoft.Json.JsonReader):
    @typing.overload
    def __init__(self, token: JToken) -> None: ...
    @typing.overload
    def __init__(self, token: JToken, initialPath: str) -> None: ...
    CurrentToken: JToken
    Path: str
    def get_CurrentToken(self) -> JToken: ...
    def Read(self) -> bool: ...
    def get_Path(self) -> str: ...

class JTokenType(System.Enum, int):
    None: JTokenType = ...
    Object: JTokenType = ...
    Array: JTokenType = ...
    Constructor: JTokenType = ...
    Property: JTokenType = ...
    Comment: JTokenType = ...
    Integer: JTokenType = ...
    Float: JTokenType = ...
    String: JTokenType = ...
    Boolean: JTokenType = ...
    Null: JTokenType = ...
    Undefined: JTokenType = ...
    Date: JTokenType = ...
    Raw: JTokenType = ...
    Bytes: JTokenType = ...
    Guid: JTokenType = ...
    Uri: JTokenType = ...
    TimeSpan: JTokenType = ...

class JTokenWriter(Newtonsoft.Json.JsonWriter):
    @typing.overload
    def __init__(self, container: JContainer) -> None: ...
    @typing.overload
    def __init__(self, ) -> None: ...
    CurrentToken: JToken
    Token: JToken
    def get_CurrentToken(self) -> JToken: ...
    def get_Token(self) -> JToken: ...
    def Flush(self) -> None: ...
    def Close(self) -> None: ...
    def WriteStartObject(self) -> None: ...
    def WriteStartArray(self) -> None: ...
    def WriteStartConstructor(self, name: str) -> None: ...
    def WritePropertyName(self, name: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.UInt32) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.UInt64) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: bool) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.UInt16) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.Char) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.Byte) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.SByte) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.Decimal) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.DateTime) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.DateTimeOffset) -> None: ...
    @typing.overload
    def WriteValue(self, value: list[System.Byte]) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.TimeSpan) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.Guid) -> None: ...
    @typing.overload
    def WriteValue(self, value: System.Uri) -> None: ...
    def WriteNull(self) -> None: ...
    def WriteUndefined(self) -> None: ...
    def WriteRaw(self, json: str) -> None: ...
    def WriteComment(self, text: str) -> None: ...

class JValue(JToken):
    @typing.overload
    def __init__(self, other: JValue) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: System.Decimal) -> None: ...
    @typing.overload
    def __init__(self, value: System.Char) -> None: ...
    @typing.overload
    def __init__(self, value: System.UInt64) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @typing.overload
    def __init__(self, value: System.DateTime) -> None: ...
    @typing.overload
    def __init__(self, value: System.DateTimeOffset) -> None: ...
    @typing.overload
    def __init__(self, value: bool) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: System.Guid) -> None: ...
    @typing.overload
    def __init__(self, value: System.Uri) -> None: ...
    @typing.overload
    def __init__(self, value: System.TimeSpan) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    HasValues: bool
    Type: JTokenType
    Value: typing.Any
    def WriteToAsync(self, writer: Newtonsoft.Json.JsonWriter, cancellationToken: System.Threading.CancellationToken, converters: list[Newtonsoft.Json.JsonConverter]) -> System.Threading.Tasks.Task: ...
    def get_HasValues(self) -> bool: ...
    @staticmethod
    def CreateComment(value: str) -> JValue: ...
    @staticmethod
    def CreateString(value: str) -> JValue: ...
    @staticmethod
    def CreateNull() -> JValue: ...
    @staticmethod
    def CreateUndefined() -> JValue: ...
    def get_Type(self) -> JTokenType: ...
    def get_Value(self) -> typing.Any: ...
    def set_Value(self, value: typing.Any) -> None: ...
    def WriteTo(self, writer: Newtonsoft.Json.JsonWriter, converters: list[Newtonsoft.Json.JsonConverter]) -> None: ...
    @typing.overload
    def Equals(self, other: JValue) -> bool: ...
    @typing.overload
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @typing.overload
    def ToString(self) -> str: ...
    @typing.overload
    def ToString(self, format: str) -> str: ...
    @typing.overload
    def ToString(self, formatProvider: System.IFormatProvider) -> str: ...
    @typing.overload
    def ToString(self, format: str, formatProvider: System.IFormatProvider) -> str: ...
    def CompareTo(self, obj: JValue) -> int: ...

class LineInfoHandling(System.Enum, int):
    Ignore: LineInfoHandling = ...
    Load: LineInfoHandling = ...

class MergeArrayHandling(System.Enum, int):
    Concat: MergeArrayHandling = ...
    Union: MergeArrayHandling = ...
    Replace: MergeArrayHandling = ...
    Merge: MergeArrayHandling = ...

class MergeNullValueHandling(System.Enum, int):
    Ignore: MergeNullValueHandling = ...
    Merge: MergeNullValueHandling = ...

T = typing.TypeVar('T')

class <>c__0[T]:
    def __init__(self, ) -> None: ...
    <>9: list[T]
    <>9__0_0: dict[T, list[JToken]]

T = typing.TypeVar('T')

class <>c__1[T]:
    def __init__(self, ) -> None: ...
    <>9: list[T]
    <>9__1_0: dict[T, list[JToken]]

T = typing.TypeVar('T')

class <>c__2[T]:
    def __init__(self, ) -> None: ...
    <>9: list[T]
    <>9__2_0: dict[T, list[JToken]]

T = typing.TypeVar('T')

class <>c__3[T]:
    def __init__(self, ) -> None: ...
    <>9: list[T]
    <>9__3_0: dict[T, list[JToken]]

class <>c:
    def __init__(self, ) -> None: ...
    <>9: <>c
    <>9__4_0: dict[JObject, list[JProperty]]

T = typing.TypeVar('T'), U = typing.TypeVar('U')

class <Values>d__11[T, U]:
    def __init__(self, <>1__state: int) -> None: ...
    <>3__source: list[T]
    <>3__key: typing.Any

T = typing.TypeVar('T'), U = typing.TypeVar('U')

class <>c__13[T, U]:
    def __init__(self, ) -> None: ...
    <>9: dict[T, U]
    <>9__13_0: dict[T, list[JToken]]

T = typing.TypeVar('T'), U = typing.TypeVar('U')

class <Convert>d__14[T, U]:
    def __init__(self, <>1__state: int) -> None: ...
    <>3__source: list[T]

class <GetDescendants>d__36:
    def __init__(self, <>1__state: int) -> None: ...
    <>3__self: bool
    <>4__this: JContainer

class JObjectDynamicProxy(list[JObject]):
    def __init__(self, ) -> None: ...
    def TryGetMember(self, instance: JObject, binder: System.Dynamic.GetMemberBinder, result: System.Object&) -> bool: ...
    def TrySetMember(self, instance: JObject, binder: System.Dynamic.SetMemberBinder, value: typing.Any) -> bool: ...
    def GetDynamicMemberNames(self, instance: JObject) -> list[str]: ...

class <>c:
    def __init__(self, ) -> None: ...
    <>9: <>c
    <>9__30_0: dict[JProperty, JToken]

class <GetEnumerator>d__63:
    def __init__(self, <>1__state: int) -> None: ...
    <>4__this: JObject

class JPropertyList:
    def __init__(self, ) -> None: ...
    Count: int
    IsReadOnly: bool
    Item: JToken
    def GetEnumerator(self) -> list[JToken]: ...
    def Add(self, item: JToken) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: JToken) -> bool: ...
    def CopyTo(self, array: list[JToken], arrayIndex: int) -> None: ...
    def Remove(self, item: JToken) -> bool: ...
    def get_Count(self) -> int: ...
    def get_IsReadOnly(self) -> bool: ...
    def IndexOf(self, item: JToken) -> int: ...
    def Insert(self, index: int, item: JToken) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    def get_Item(self, index: int) -> JToken: ...
    def set_Item(self, index: int, value: JToken) -> None: ...

class LineInfoAnnotation:
    def __init__(self, lineNumber: int, linePosition: int) -> None: ...

class <GetAncestors>d__48:
    def __init__(self, <>1__state: int) -> None: ...
    <>3__self: bool
    <>4__this: JToken

class <AfterSelf>d__49:
    def __init__(self, <>1__state: int) -> None: ...
    <>4__this: JToken

class <BeforeSelf>d__50:
    def __init__(self, <>1__state: int) -> None: ...
    <>4__this: JToken

T = typing.TypeVar('T')

class <Annotations>d__184[T]:
    def __init__(self, <>1__state: int) -> None: ...
    <>4__this: JToken

class <Annotations>d__185:
    def __init__(self, <>1__state: int) -> None: ...
    <>3__type: System.Type
    <>4__this: JToken

class JValueDynamicProxy(list[JValue]):
    def __init__(self, ) -> None: ...
    def TryConvert(self, instance: JValue, binder: System.Dynamic.ConvertBinder, result: System.Object&) -> bool: ...
    def TryBinaryOperation(self, instance: JValue, binder: System.Dynamic.BinaryOperationBinder, arg: typing.Any, result: System.Object&) -> bool: ...

class <>c:
    def __init__(self, ) -> None: ...
    <>9: <>c
    <>9__2_0: dict[JProperty, str]

class <GetEnumerator>d__1:
    def __init__(self, <>1__state: int) -> None: ...
    <>4__this: JPropertyList

