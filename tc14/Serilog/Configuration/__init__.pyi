import Serilog
import Serilog.Core
import Serilog.Events
import System
import System.Collections.Generic
import System.Reflection
import typing

class ILoggerSettings:
    def __init__(self , *args: typing.Any) -> None: ...
    def Configure(self, loggerConfiguration: Serilog.LoggerConfiguration) -> None: ...

class LoggerAuditSinkConfiguration:
    @typing.overload
    def Sink(self, logEventSink: Serilog.Core.ILogEventSink, restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ..., levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Sink(self, restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ..., levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Logger(self, configureLogger: list[Serilog.LoggerConfiguration], restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ..., levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Logger(self, logger: Serilog.ILogger, restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ...) -> Serilog.LoggerConfiguration: ...

class LoggerDestructuringConfiguration:
    @typing.overload
    def AsScalar(self, scalarType: System.Type) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def AsScalar(self) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def With(self, destructuringPolicies: list[Serilog.Core.IDestructuringPolicy]) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def With(self) -> Serilog.LoggerConfiguration: ...
    def ByTransforming(self, transformation: dict[TValue, typing.Any]) -> Serilog.LoggerConfiguration: ...
    def ByTransformingWhere(self, predicate: dict[System.Type, bool], transformation: dict[TValue, typing.Any]) -> Serilog.LoggerConfiguration: ...
    def ToMaximumDepth(self, maximumDestructuringDepth: int) -> Serilog.LoggerConfiguration: ...
    def ToMaximumStringLength(self, maximumStringLength: int) -> Serilog.LoggerConfiguration: ...
    def ToMaximumCollectionCount(self, maximumCollectionCount: int) -> Serilog.LoggerConfiguration: ...

class LoggerEnrichmentConfiguration:
    @typing.overload
    def With(self, enrichers: list[Serilog.Core.ILogEventEnricher]) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def With(self) -> Serilog.LoggerConfiguration: ...
    def WithProperty(self, name: str, value: typing.Any, destructureObjects: bool = False) -> Serilog.LoggerConfiguration: ...
    def FromLogContext(self) -> Serilog.LoggerConfiguration: ...
    def When(self, condition: dict[Serilog.Events.LogEvent, bool], configureEnricher: list[LoggerEnrichmentConfiguration]) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def AtLevel(self, enrichFromLevel: Serilog.Events.LogEventLevel, configureEnricher: list[LoggerEnrichmentConfiguration]) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def AtLevel(self, levelSwitch: Serilog.Core.LoggingLevelSwitch, configureEnricher: list[LoggerEnrichmentConfiguration]) -> Serilog.LoggerConfiguration: ...
    @staticmethod
    def Wrap(loggerEnrichmentConfiguration: LoggerEnrichmentConfiguration, wrapEnricher: dict[Serilog.Core.ILogEventEnricher, Serilog.Core.ILogEventEnricher], configureWrappedEnricher: list[LoggerEnrichmentConfiguration]) -> Serilog.LoggerConfiguration: ...

class LoggerFilterConfiguration:
    @typing.overload
    def With(self, filters: list[Serilog.Core.ILogEventFilter]) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def With(self) -> Serilog.LoggerConfiguration: ...
    def ByExcluding(self, exclusionPredicate: dict[Serilog.Events.LogEvent, bool]) -> Serilog.LoggerConfiguration: ...
    def ByIncludingOnly(self, inclusionPredicate: dict[Serilog.Events.LogEvent, bool]) -> Serilog.LoggerConfiguration: ...

class LoggerMinimumLevelConfiguration:
    def Is(self, minimumLevel: Serilog.Events.LogEventLevel) -> Serilog.LoggerConfiguration: ...
    def ControlledBy(self, levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    def Verbose(self) -> Serilog.LoggerConfiguration: ...
    def Debug(self) -> Serilog.LoggerConfiguration: ...
    def Information(self) -> Serilog.LoggerConfiguration: ...
    def Warning(self) -> Serilog.LoggerConfiguration: ...
    def Error(self) -> Serilog.LoggerConfiguration: ...
    def Fatal(self) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Override(self, source: str, levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Override(self, source: str, minimumLevel: Serilog.Events.LogEventLevel) -> Serilog.LoggerConfiguration: ...

class LoggerSettingsConfiguration:
    def Settings(self, settings: ILoggerSettings) -> Serilog.LoggerConfiguration: ...
    def KeyValuePairs(self, settings: list[dict[str, str]]) -> Serilog.LoggerConfiguration: ...

class LoggerSinkConfiguration:
    @typing.overload
    def Sink(self, logEventSink: Serilog.Core.ILogEventSink, restrictedToMinimumLevel: Serilog.Events.LogEventLevel) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Sink(self, logEventSink: Serilog.Core.ILogEventSink, restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ..., levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Sink(self, restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ..., levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Logger(self, configureLogger: list[Serilog.LoggerConfiguration], restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ..., levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...
    @typing.overload
    def Logger(self, logger: Serilog.ILogger, restrictedToMinimumLevel: Serilog.Events.LogEventLevel = ...) -> Serilog.LoggerConfiguration: ...
    def Conditional(self, condition: dict[Serilog.Events.LogEvent, bool], configureSink: list[LoggerSinkConfiguration]) -> Serilog.LoggerConfiguration: ...
    @staticmethod
    @typing.overload
    def Wrap(loggerSinkConfiguration: LoggerSinkConfiguration, wrapSink: dict[Serilog.Core.ILogEventSink, Serilog.Core.ILogEventSink], configureWrappedSink: list[LoggerSinkConfiguration]) -> Serilog.LoggerConfiguration: ...
    @staticmethod
    @typing.overload
    def Wrap(loggerSinkConfiguration: LoggerSinkConfiguration, wrapSink: dict[Serilog.Core.ILogEventSink, Serilog.Core.ILogEventSink], configureWrappedSink: list[LoggerSinkConfiguration], restrictedToMinimumLevel: Serilog.Events.LogEventLevel, levelSwitch: Serilog.Core.LoggingLevelSwitch) -> Serilog.LoggerConfiguration: ...

TValue = typing.TypeVar('TValue')

class <>c__DisplayClass11_0[TValue]:
    def __init__(self, ) -> None: ...
    transformation: dict[TValue, typing.Any]

TValue = typing.TypeVar('TValue')

class <>c__11[TValue]:
    def __init__(self, ) -> None: ...
    <>9: list[TValue]
    <>9__11_0: dict[System.Type, bool]

TValue = typing.TypeVar('TValue')

class <>c__DisplayClass12_0[TValue]:
    def __init__(self, ) -> None: ...
    transformation: dict[TValue, typing.Any]

class <>c__DisplayClass7_0:
    def __init__(self, ) -> None: ...
    condition: dict[Serilog.Events.LogEvent, bool]

class <>c__DisplayClass8_0:
    def __init__(self, ) -> None: ...
    enrichFromLevel: Serilog.Events.LogEventLevel
    <>9__1: dict[Serilog.Events.LogEvent, bool]

class <>c__DisplayClass9_0:
    def __init__(self, ) -> None: ...
    levelSwitch: Serilog.Core.LoggingLevelSwitch
    <>9__1: dict[Serilog.Events.LogEvent, bool]

class <>c__DisplayClass5_0:
    def __init__(self, ) -> None: ...
    exclusionPredicate: dict[Serilog.Events.LogEvent, bool]

class <>c__DisplayClass8_0:
    def __init__(self, ) -> None: ...
    condition: dict[Serilog.Events.LogEvent, bool]

