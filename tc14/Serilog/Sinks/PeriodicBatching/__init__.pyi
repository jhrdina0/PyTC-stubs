import Serilog.Events
import System
import System.Collections.Generic
import System.Threading.Tasks
import typing

class BatchedConnectionStatus:
    def __init__(self, period: System.TimeSpan) -> None: ...
    NextInterval: System.TimeSpan
    ShouldDropBatch: bool
    ShouldDropQueue: bool
    def MarkSuccess(self) -> None: ...
    def MarkFailure(self) -> None: ...
    def get_NextInterval(self) -> System.TimeSpan: ...
    def get_ShouldDropBatch(self) -> bool: ...
    def get_ShouldDropQueue(self) -> bool: ...

T = typing.TypeVar('T')

class BoundedConcurrentQueue[T]:
    def __init__(self, queueLimit: list[int]) -> None: ...
    Unbounded: int
    Count: int
    def get_Count(self) -> int: ...
    def TryDequeue(self, item: T&) -> bool: ...
    def TryEnqueue(self, item: T) -> bool: ...

class IBatchedLogEventSink:
    def __init__(self , *args: typing.Any) -> None: ...
    def EmitBatchAsync(self, batch: list[Serilog.Events.LogEvent]) -> System.Threading.Tasks.Task: ...
    def OnEmptyBatchAsync(self) -> System.Threading.Tasks.Task: ...

class PeriodicBatchingSink:
    def __init__(self, batchedSink: IBatchedLogEventSink, options: PeriodicBatchingSinkOptions) -> None: ...
    NoQueueLimit: int
    def Dispose(self) -> None: ...
    def Emit(self, logEvent: Serilog.Events.LogEvent) -> None: ...

class PeriodicBatchingSinkOptions:
    def __init__(self, ) -> None: ...
    EagerlyEmitFirstEvent: bool
    BatchSizeLimit: int
    Period: System.TimeSpan
    QueueLimit: list[int]
    def get_EagerlyEmitFirstEvent(self) -> bool: ...
    def set_EagerlyEmitFirstEvent(self, value: bool) -> None: ...
    def get_BatchSizeLimit(self) -> int: ...
    def set_BatchSizeLimit(self, value: int) -> None: ...
    def get_Period(self) -> System.TimeSpan: ...
    def set_Period(self, value: System.TimeSpan) -> None: ...
    def get_QueueLimit(self) -> list[int]: ...
    def set_QueueLimit(self, value: list[int]) -> None: ...

class PortableTimer:
    def __init__(self, onTick: dict[System.Threading.CancellationToken, System.Threading.Tasks.Task]) -> None: ...
    def Start(self, interval: System.TimeSpan) -> None: ...
    def Dispose(self) -> None: ...

